
		AVLRCU

Abstract:
	- No lock-less BST in the linux kernel. Only the latch-based RB tree.
	- This implementation provides the infrastructure for RCU-compatible AVL tree.
	- 2 write-side operations: insert and delete.
	- The implementation is lock-less with respect to the in-order traversal and search operations.
	- No RCU/write-side locking primitives are called, they must be provided (and be compatible) by the user.

Why AVL tree:
	- For lookup-intensive applications, AVL trees are faster than redâ€“black trees because they are more strictly balanced.
	- The logic behind AVL trees balancing is simpler (than that of RB-trees).
	- The algorithm is based solely on tree rotations.
	- A tree rotation changes the structure without interfering with the order of the elements.
	- A tree rotation renders the inorder traversal of the binary tree invariant.
	  (Figure: left and right rotations + rotation tables.)
	- I will not explain the AVL tree algorithm here, this information is available everywhere.

Some stuff about RCU:
	- Similar to other RCU-compatible data structures, the algorithm works by replacing pointers. No special instructions are needed.
	- Maintains multiple versions of the data during replacement to safely carry out changes in presence of concurrent readers.
	- The only compatible read-side operations are in-order taversal and search.
	- These can be implemented by simply traversing pointers, without the help of additional data structures.
	- Read-side operations see the data structure before/during/after the write operation, no intermediate state.

The algorithm:
	- The algorithm can be considered a composition of seemingly atomic operations (with respect to walk/search operations) on the tree.
	- Atomicity is ensured by the sequence of pointer assignment on the write-side, to which the read-side operations are immune.
	- Atomic operations: rotations, insertion of leaf, deletion of leaf.
	  (Figure: An atomic rotation, insertion and deletion)
	- At every level, nodes are split into rotated nodes (root, pivot) and unaffected nodes (t1, t2, t3). TODO: unaffected sounds bad
	  (Figure: The root, pivot + encircled subtrees before a rotation, then the same at the next level.)
	- The preallocated branch is composed of rotated/inserted/deleted nodes at every level.
	- The preallocated branch is a connected component of the tree.

	- The implementation works by allocating the new tree topology in parallel, then connecting it to the tree.
	- Callbacks must be provided for allocating, copying, freeing the nodes of the tree.
	- The changes are accumulated in the 'preallocated' branch.
	- Nodes are replaced and rearranged by copying them (shallow copy) and modifying the links in the 'preallocated' branch.
	- The tree topology is changed by successive rotations.
	  (Figure: How a rotation looks on the preallocated branch + forward links)
	- The algorith ascends (insert/delete retrace) or descends (unwind) and brings (copies) a node to the preallocated branch.

	- When the changes are complete, the preallocated branch is connected to the tree.
	- The nodes being replaced are chained and RCU deleted (reclaimed at the end of the grace period).
	- Those old nodes are still connected to the tree, but only the outgoing links.
	  (Figure: How the tree looks after the preallocated branch has been connected.)
	- Connecting the new branch to the tree is done clockwise starting with the rightmost node and ending at root.
	- The walk operation will enter an unaffected subtree from the old branch and will exit into the preallocated branch.
	- Ordering is preserved (TODO: that remains to be proven!!)
	- Search will always descend into the old version of the tree (root gets connected last).

Insertion:
	- Just like regular insertion.
	- New node gets attached at the bottom, then the tree is rebalanced.
	- New node starts the preallocated branch.
	- The preallocated branch ascends along the parent with each retrace step.

Deletion:
	- Nothing like regular deletion.
	- Replacing 2 nodes at different places in the tree is not atomic.
	- The only way a node can be removed in an atomic fashion is if it's a leaf.
	- The node must be bubbled down to a leaf position (unwind).
	- Bubbling is done thru rotations. Each rotation increases the depth of the bubbled node.
	- After each rotation, the bubbled node has a different view of the subtree it roots.
	  (Figure: What the bubbled node sees from the bottom of the preallocated branch.)
	- The rotations are chosen in such a way to respect a few invariants:
		- The balance factor of the new root can be in the range +-2.
		- The balance factor of the new pivot can be in the range +-1.
					or
		- After a (simple/compound) rotation, the subtree at the next level will also be an AVL tree.
	- Simple rotations can be done only for nodes with balance factors of +-1.
	- After a rotation, the new pivot gets the nearest subtree of the old pivot.
	- That's why the pivot has to be conditioned before the rotation if it has balance towards the root.
	  (the nearest subtree must be the short one, not the long one)
	- Simple rotations obtain an equivalent AVL tree (no height increase).

	- Compound reverse rotations are done when the root has balance factor 0.
	- The rotations are chosen based on the left and right children.
	  (Left/right pivot conditioning also applies here.)
	- Only reverse compound rotations increase the height of the preallocated branch.

	- All balance factors after rotations point towards the preallocated branch.
	- Balance factors of +-2 will be fixed by double rotations.
	- First balance factor of +-2 will be canceled by target node deletion (which has become a leaf).
	- Fixing continues to the top of the preallocted branch.
	- The preallocated branch may have decreased in size as result of deletion.
	- A delete retrace starts all the way to the root.

Drawbacks:
	- The nodes must be small (an allocation + copy is done each time a node is brought into the preallocated branch).
	- Readers shall not modify the contents of the nodes (changes may be lost due to replacing the nodes).
	- The nodes will have an extra RCU head unioned with algorithm state variables.

References:
	https://en.wikipedia.org/wiki/AVL_tree
	https://en.wikipedia.org/wiki/AVL_tree#cite_note-Pfaff1-4
	https://www.kernel.org/doc/Documentation/RCU/
	https://lwn.net/Articles/262464/
